### 2.1.수
- [x] **#1874 스택 수열** : 시간초과 남. `deque` 썼는데 여전히 남. `not in` 때문인 거 같음. 앞부터 하나하나 다 확인하니까.

#### 느낀 점
- 실버부터 `시간 초과`나는 일이 잦음. list의 `in`, `not in`은 순회탐색이라 비효율적이므로 사용 지양할 것

### 2.3.금
- [x] **#1874 스택 수열** : `not in` 해결할 차례

-> YAGNI한 `if`문 발견, 제거. 여전히 시간초과 뜸
-> 질문게시판에서 출력 시간 줄이는 법 배움 : `print('\n'.join(ans))`

#### 느낀 점
리스트에서 슬라이싱이랑 `in/not in`은 시간초과 잘 나니까 주의하자.<br>
`==`, `in`, `not in` : O(n) <br>
`in` 은 `set` 자료에서 적합하다. 집합에선 O(1)이라. 리스트에서는 O(n)임.<br>

### 2.4.토
- [x] __#25682 체스판 다시 칠하기 2__ : 체스판은 2차원이니까 2차원 누적합 배열이 필요한가?

### 2.5.일
- [x] __#25682 체스판 다시 칠하기 2__ : 구글링 해서 정답 확인

### 2.6.월
**백준 `집합과 맵` 시작**
- [x] __#10815 숫자 카드__ : `Set` 안 썼더니 시간초과 남. `{map()}`이 아니라 `set(map())` 이렇게 <br>
- [x] __#14425 문자열 집합__ : 입력 받는 m은 중복이어도 개수 세야 하므로 `set`이 아닌 `list`여야 함
- [x] __#10126__ : `set` 안 쓰고 `list`에 `counter`쓰니까 통과함

#### 느낀 점
- `not in`이나 `in` 때문에 시간 많이 들면 `set` 자료형 쓰면 됨<br>

### 2.7.화
- [x] __#18258 큐 2__ : 시간초과. sys써서 통과
- [x] __#2164 카드2__
- [x] __#11866 요세푸스 문제0__ : 원형(circular) 큐를 구현해야 하나 싶었는데 선형으로 구현 가능함

#### 알고리즘
큐에 1부터 n까지 작은 수부터 순서대로 삽입한다.<br>
다음을 n-1회 반복한다.<br>
    1. k-1회 큐에서 수를 꺼낸 다음 곧바로 다시 삽입한다.<br>
    2. 큐에서 수를 하나 꺼낸다. 이 수가 다음으로 제거되는 수이며, 다시 삽입하지 않는다.<br
큐에 남아있는 수가 마지막에 남는 수이다.<br>

### 2.8.수
- [x] __#1966 프린트 큐__ : `copy`를 써야할 듯.
- [x] __#11866 요세푸스 문제0__ : 질문 게시판 둘러보다가 `deque.rotate` 알게 됨.

### 2.10.금
- [x] __#1966 프린트 큐__ : copy 안 쓰고 싶어서 구글링 함. AC
- [x] __#1021 회전하는 큐__

### 2.12.일
- [x] __#1021 회전하는 큐__ : 조건 실수, 부등호 같을 때 고려 안 함, left와 right 반대, 이미 뺀 거 지나갈 때 부분 수정. 여전히 테케 만족 못함.

### 2.13.월.
- [x] __#1021 회전하는 큐__ : 구글링해서 `deque.index` 알게 됨. -> 이걸로 AC
- [x] __#5430 AC__

#### 느낀 점
- `filter()` 사용법 좀 알아보자

### 2.14.화
- [x] __#5430 AC__ : 어제 수정 못한 error 출력부분만 수정.
-> 오류난 이유 : 지금 42가 하나의 숫자로 안 들어가고 4,2로 들어가있음. 콤마를 기준으로 숫자가 안 나뉘어짐<br>
-> 테케 통과했는데 시간초과 남 -> 슬라이싱 때문 + queue.reverse() 이거 사용해서 뒤집으면 시간초과 남<br>
-> 대괄호 없애기 위해 `filter` 썼는데 콤마를 기준으로 나뉘지 않아서 숫자가 42일 때 4,2로 들어갔음.<br>
문자열로 받으면 비어있을 때 ‘’문자열 기호가 남기 때문에 오류가 남 -> clear해서 다 날려버림<br>
시간초과는 reverse() 때문임 -> R의 갯수를 세서 홀수 짝수일때 pop/popleft()로 접근할 것<br>
-> 틀린 이유 : Reverse 되어있을 땐 Reverse된 형태로 출력해야 했음 -> 고치고 AC <br>

#### 느낀 점 & 배운 점
- `filter(조건 함수, 순회 가능한 데이터)`<br>
두번째 인자로 넘어온 데이터 중에서 첫번째 인자로 넘어온 조건 함수를 만족하는 데이터만 반환<br>
- `deque([‘’])` `empty`가 아님. len = 1임.<br>

### 2.15.수
**백준 `우선순위 큐` 시작**
- [x] __#11279 최대 힙__
- [x] __#1927 최소 힙__
- [x] __#11286 절댓값 힙__
- [x] 집합과 맵 __#1764 듣보잡__ : 집합문제인 거 잊고 그냥 리스트 썼다가 시간초과 뜸
- [x] __#1269 대칭 차집합__

### 2.16.목
**백준 `이분탐색` 시작**
-> 집합과 맵 끝내고 실버 1됨!<br>
- [x] __#11478 서로 다른 부분 문자열의 개수__
- [x] __#1620 나는야 포켓몬 마스터 이다솜__
- [x] __#1920 수 찾기__
- [x] __#1654 랜선 자르기__

#### 느낀 점
- 문제를 보고 이분탐색으로 푼다는 걸 한 번에 알아차리지 못하고 있음.
- `parametric search` 찾아보자

### 2.17.금
- [x] 파라메트릭 서치 -> 최적화 문제를 결정 문제 (yes or no)로 바꾸는 것. 범위 내에서 조건을 만족하는 가장 큰 값 찾기 같은 문제

### 2.19.일
- [x] __#1654 랜선 자르기__ : 이분탐색 & 파라메트릭 서치 <br>
-> 테케는 맞췄는데 시간 초과 남, 어차피 최대값이라는 보장도 없어서 수정하긴 해야함. 근데 왜 시간초과지?? 그리고 end가 반드시 lst[0]이라는 보장도 없음<br>
-> while문 조건에 start 가 end랑 같을 경우 무한 루프 도는 거 예외처리 추가해줘서 시간초과는 해결함. 근데 틀렸습니다 뜸. 아마 최대값이 아니라 그런거 같음<br>
-> lst[0]말고 max(lst)로 바꿨는데도 틀렸습니다.<br>
-> 반례 : 4 8 / 13 13 13 13

### 2.20.월
- [x] __#1654 랜선 자르기__ : 반례 통과를 위한 재도전<br>
-> start = 1 이 아니라 0으로 바꾸니까 위 반례는 통과, but 틀렸습니다.<br>
-> 반례 : 5 5 / 1 2 3 4 이 반례 고쳤는데 여전히 틀림<br>
-> 반례 : 4 4 / 200 200 200 1 이 반례 고쳤는데 여전히 틀림<br>
-> 반례 : 1 1 / 2147483647<br>
-> 반례 : 5 5 / 1 1 1 1 1 -> 0으로 못 나눈다고 뜸;<br>
-> 결국 구글링. 일단 start = 1이어야 했음. 0 이면 나눗셈 몫에 0이 들어가니까. 그리고 마지막 출력이 mid가 아닌 end였음.<br>
또, while문 조건도 이진탐 색때랑 같았고 if 조건은 작을 때. 그 외는 무조건 만족하는 거니까 상관없음<br>

- [x] __#2805 나무 자르기__ : 마이너스값이 더해지는 것 주의하기

### 2.21.화
- [x] __#2110 공유기 설치__ : 어디에 이분 탐색 쓰는지 감이 안 와서 구글링 후 아이디어만 확인.<br>
-> 이 문제의 경우, `cnt<c`일 때 `end = mid-1`로 바꾸면 정답 `mid`값을 넘어갈 수도 있음<br>
-> 진짜 도저히 못 고치겠어서 구글링 함 -> `cnt`를 1부터 시작해서 `arr[1]`부터 찾도록 구현하니까 됨. 차이점이 뭐지?<br>
-> `cnt >= c` 조건에서 `ans = mid`하나 추가했더니 넘어감. 차이가 뭐지?? <br>

#### 느낀 점 & 의문 점
- 의문 : 첫 집은 무조건 설치 해야하나? (안 해도 될 거 같다고 생각)<br>
- 이분탐색에서 개수나 길이 처럼 두 개를 동시에 신경 써야하는 문제는 불변하는 것(개수)을 잊고 일단 길이를 조절하면서 개수 만족? 만족? 이런 식으로 확인한다.<br>
- 이분탐색에서 `end`는 항상 최댓값이다. (마지막 값이 아님! 가질 수 있는 최댓값)<br>

### 2.22.수
- [x] __#1920 수 찾기__ : 다른 방법으로 품
- [x] __#2110 공유기 설치__ <br>
-> __어제 의문의 답__ : 항상 첫 번째 두는 것이 최적해이다.<br>
-> 추가 의문 : 이분 탐색에서 `while` 문의 조건은 늘 `start <= end` 인가?<br>
-> 이 문제에서 공유기를 c개 설치하는 것과 c개 이상 설치하는 경우 답이 같다고 한다. 왜?<br>
-> `ans = mid` 추가해서 통과한 거였음. 조건은 상관이 없고 ( cnt<c가 먼전지 cnt>=c가 먼전지), cnt >= c일 때 ans = mid넣고 ans출력하니까 답이 되네<br>

- [x] __#1300 k번째 수__ : 메모리 초과 남.
-> 2차원 배열에 수 넣는 법 : `arr = [[i*j for j in range(1, n+1)] for i in range(1, n+1)]` <br>
-> 메모리 초과라는 건 배열을 무식하게 2차원, 1차원 구현하지 말고 규칙을 찾아야 한다는 뜻<br>
-> 일단, b를 오름차순으로 정렬하면 k번째 수는 반드시 k보다 작거나 같음<br>
-> 도저히 규칙 모르겠어서 구글링. `tmp >= k`일 때 `result = mid`해서 `result` 출력.

#### 느낀 점 & 의문 점
- 내가 `이분탐색`에서 못하는 거 : 조건이 두 갈래로 나뉠 때, 어떨 때 start를 움직이고 어떨 때 end를 움직이는지 확신이 없음 지금
- 매개변수 탐색과 이분 탐색이 따로 등장하는데 차이가 뭐지?

### 2.23.목
- [x] __#12015 가장 긴 증가하는 부분 수열 2__ : 테케 통과는 금방했는데 내가 예상했던 반례에서 걸림.
-> 즉, 큰 게 너무 일찍 나오면 거기서 끝나고 나옴.<br>
-> start랑 end를 값으로 할 게 아니라 인덱스로 해야하나?<br>
-> for 문 안에서 mid를 안 쓰고 있어서 그런 것 같기도 함<br>
-> 여기 mid가 필요한가?<br>

### 2.24. 금
- [x] __#12015 가장 긴 증가하는 부분 수열 2__ : 어제 반례부분 해결 못한 거 재도전<br>
-> 지금 테케가 맞는 건 `start, mid, end`가 없어도 기능하도록 되어 있어서 그럼.<br>
-> 구글링 해보니까 `memozation` 이용해서 시작은 0 집어넣고 더 크다? -> 추가 or 아니다? 이전 꺼 빼고 새로운 거 넣기<br>
-> 근데 이건 이분탐색이 아니지 않나? 싶었는데 인덱스를 이분탐색하는 것<br>

### 2.25.토
- [x] __#12015 가장 긴 증가하는 부분 수열 2__ : AC
- [x] __#1920 수 찾기__ : 다른 방법 사용해서 3번째로 품

### 2.26.일
- [x] __#10816번 숫자 카드 2__ : 이분탐색으로 푸는 중

### 2.27.월
- [x] 이분탐색 한 번 훑어보기
- [x] C언어 문법복기
- [x] __#2588 곱셈__ : 숫자가 두자리 이상일 때 하나씩 따로 저장하는 법 : scanf(“%1d%1d%1d”, &b[0], &b[1], &b[2])
-> 이때는 & 붙여줘야 함
- [x] __#11382__ : 입력값 범위 때문에 `unsigned long long` 해줬음. `long long`은 서식문자 `%lld`
- [x] __#10172__ : c에서 특문은 그냥 앞에 \백슬래시만 붙이면 됨
- [x] `입출력과 사칙연산` 단계 C로 다 품 + `조건문` 단계 푸는 중

### 2.28.화
- [x] 제대로 이해 못한 `이분탐색` 골드 3문제 다시 정리하면서 이해함
