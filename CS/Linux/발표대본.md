[1]
1주차 과제 리눅스 파일 시스템 조사와 ttop.c 소스코드 분석 발표 시작하겠습니다.

[2]
들어가기에 앞서서 과제의 목표에 대해서 잠깐 이야기를 해보려고 합니다.
처음에 과제를 받고 수행하기 전에 책임님께서 왜 이 과제를 내주셨을까를 곰곰이 생각해봤습니다. 리눅스 파일과 디렉토리를 이해하는 건 업무를 하게 되면 그만큼 리눅스를 많이 쓰고, 다양한 파일들에 접근할 일이 많아지니까 그 부분에 익숙해지라는 의미로 내주셨다고 생각했습니다. 그리고 top 명령어 같은 경우에는 이제 리눅스에 있는 파일들을 가져와서 계산을 하게 되는데 그 부분을 분석을 하다보면 리눅스 커널이라던지 cpu, 메모리 같은 컴퓨터 구조와 운영체제에 대한 전반적인 지식이 함께 필요하게 됩니다. 운영체제는 현재 하드웨어의 상태가 어떤지, 코드가 어떻게 실행되었는지와 같은 상황을 굉장히 상세하게 알려주기 때문에 운영체제를 잘 이해하고 있으면 문제가 발생했을 때 해결책의 실마리를 찾기가 쉬워집니다. 그래서 문제해결력도 함께 기를 수 있도록, 그런 것들을 고려해서 내주셨다고 생각을 했습니다.

그래서 전체적인 과제를 수행할 때 업무의 관점에서, 뭘 보고 문제가 발생했는지를 파악하는지, 어떤 값일 때 문제라고 판단을 하는지, 또 해결은 어떻게 할 수 있는지. 그런 것들을 중심으로 생각하면서 수행을 했습니다.

[3]
그래서 먼저 리눅스의 파일시스템에 대해 한 번 짚고 넘어갈 거구요, 그 안에 있는 수많은 디렉토리 중에 뒤에서 분석할 top 명령어에서 자주 쓰이는 파일들은 좀 더 자세하게 다루는 식으로 진행을 할 예정입니다. 또 top 도 시스템 정보를 나타내는 상위 5줄을 어떻게 파싱해왔는지를 중심으로 다룰 예정입니다. 그리고 마지막으로는 과제를 수행하면서 배운 점들을 어떻게 현업 업무관점에서 연결짓고 활용할지. 그 순서대로 발표를 해보겠습니다.

[4]
먼저 리눅스 파일 시스템의 특징입니다. RFS, 루트 파일 시스템.
마운트는 뒤에서 mnt디렉토리 설명할 때 더 자세하게 설명하도록 하겠습니다.

[5]
크게 실행파일, 디렉토리, 링크 파일, 장치 파일로 나눕니다.

차지하는 비율을 보시면 이게 거의 대부분을 차지.
캐릭터는 뭐고, 
블럭은 뭐다.
Socket : 네트워크 통신에 필요한 파일
FIFO : IPC, 프로세스간의 통신에 쓰이는 파이프
프로세스끼리는 기본적으로는 자원을 공유하지 않지만, 충분히 자원을 공유하고 데이터를 주고 받을 수 있습니다. 이렇게 프로세스끼리 자원 공유하고, 데이터를 주고 받는 것을 프로세스 간 통신이라고 합니다.

[6]
리눅스 디렉토리들의 각 용도. 디렉토리 이름을 보면 어느정도 용도가 유추가 가능한데요, 그중에서도 요런 것들이 중요합니다.
opt는 adaptive autosar가 설치되고
dev는 장치파일 확인 가능
proc이 뒤에 있을 가장 중요한.

[]


[task]
리눅스는 프로세스와 스레드를 구분하지 않습니다. 그 둘 모드 실행의 문맥이라는 점에서 동등하다고 간주하기 때문에 그 두 용어 대신에 태스크라는 이름으로 통일하여 명명합니다.

[slab]
슬랩은 커널 캐시입니다.

모니터링을 할 때, 메모리 사용량이 너무 많다. 그럼 프로세스가 점유하고 있는 메모리를 먼저 확인합니다. 불필요한 프로세스가 돌아가고 있을 수도 있고, 한 프로세스가 너무 많은 메모리를 쓰고 있으면 메모리 누수를 의심해볼 수도 있습니다. 근데 이제 만약에 프로세스는 메모리를 적게 사용하고 있는데도 메모리 사용량이 크다. 그럼 커널의 메모리 사용을 의심해볼 수 있습니다.

[하이퍼스레드]
하이퍼스레드는 인텔이 구현한 동시 멀티스레딩 기술입니다. 
cpu 코어 안의 레지스터 같은 일부 자원을 여러 개 준비해서 시스템 입장에서는 이것들이 각각의 논리 CPU로써 인식되게 하는 그런 기능입니다. 하이퍼스레드가 항상 좋은 성능을 보이는 것은 아니기 때문에 하이퍼스레드를 쓴 것과 안 쓴 것을 비교해서 더 성능이 좋은 쪽을 선택하는 것으로 압니다.


[문맥교환]
문맥 교환, context switching에 대한 말이 나오는데 문맥 교환은 논리 cpu 상에서 동작하는 프로세스가 바뀌는 것을 말합니다. 여기서 문맥은 이제 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보입니다.
어, 이제 운영체제는 프로세스에 cpu 같은 자원을 배분을 하는데 이때 PCB라고 하는, process control block을 이용하게 됩니다. pcb는 커널 영역에 생성이 되구요, 프로세스가 생성됐을 때 만들어지고, 실행이 끝나면 폐기가 되는 그런 자료 구조입니다. 그래서 새로운 프로세스를 실행하고 싶다, 그러면 기존에 실행중이던 프로세스의 문맥을 pcb에 백업을 하고, 새로운 프로세스를 실행하기 위한 문맥을 pcb로부터 복구해서 실행하게 되는데 이런 일련의 과정을 문맥 교환이라고 합니다.

문맥 교환이 자주 일어나면 프로세스는 그만큼 빨리 번갈아 수행되기 때문에 사용자 입장에서는 동시에 실행되는 것처럼 보이지만, 너무 자주 교환하면 오버헤드가 발생할 수 있기 때문에 반드시 좋은 것은 아닙니다.


[마지막]
과제는 끝이 났구요, 과제를 하면서 배운 것들을 어떻게 업무에 적용할까, 생각을 해봤습니다.
학부 때의 경험을 돌이켜봐도, 임베디드 프로젝트를 하다보면 문제가 굉장히 빈번하게 발생을 했습니다. 실질적으로 개발에 썼던 시간보다 문제 원인을 찾는데 시간을 더 많이 썼던 것 같은데, 프로세스들이 어떻게 돌아가고 있고, 리눅스의 파일구조가 어떻게 이루어졌는지를 이해하게 돼서 후에 문제가 발생한다면, 더 빠르게 해결을 할 수 있을 것 같습니다.

제 발표는 여기까지구요, 들어주셔서 감사합니다.
