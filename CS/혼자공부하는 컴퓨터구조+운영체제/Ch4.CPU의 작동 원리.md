# CH04 CPU의 작동 원리

## 04-1 ALU와 제어장치

## ALU
- ALU는 `레지스터`로부터 `피연산자`를 받아들이고, `제어장치`로부터 `제어 신호`를 받아들인다.
- ALU는 레지스터와 제어장치로부터 받아들인 피연산자와 제어 신호로 산술 연산, 논리 연산 등 다양한 연산을 수행한다.
- ALU는 연산한 `결과값`과 `플래그`를 내보낸다.
- 이때, 연산을 수행한 결과는 메모리에 저장되지 않고 `일시적으로 레지스터에 저장`된다. 레지스터에 접근하는 것이 메모리에 접근하는 것보다 훨씬 빠르기 때문이다.

### 플래그
- 연산 결과에 대한 추가적인 상태 정보를 플래그라고 한다.
- ALU가 내보내는 대표적인 플래그는 아래와 같다.

|플래그 종류|의미|사용 예시|
|--|--|--|
|부호 플래그|연산한 결과의 부호를 나타낸다.|1일 경우 음수, 0일 경우 양수|
|제로 플래그|연산 결과가 0인지 여부를 나타낸다.|1일 경우 연산 결과는 1, 0일 경우 0 아님|
|캐리 플래그|연산 결과 올림수나 빌림수가 발생했는지를 나타낸다.|1일 경우 올림수나 빌림수 발생, 0일 경우 발생 안 함|
|`오버플로우` 플래그|오버플로우가 발생했는지를 나타낸다.|1일 경우 오버플로우 발생, 0일 경우 발생 안 함|
|인터럽트 플래그|인터럽트가 가능한지를 나타낸다.|1일 경우 인터럽트 가능, 0일 경우 불가능|
|슈퍼바이저 플래그|커널 모드로 실행 중인지, 사용자 모드로 시행 중인지를 나타낸다.|1일 경우 커널 모드로 실행 중, 0일 경우 사용자 모드로 실행 중|

오버플로우 : 연산 결과가 연산 결과를 담을 레지스터보다 큰 상황

- 이러한 플래그들은 `플래그 레지스터`에 저장된다. 


## 제어장치
- 제어장치는 제어 신호를 내보내고, 명령어를 해석하는 부품이다.
- `제어 신호`는 컴퓨터 부품들을 괄니하고 작동시키기 위한 일종의 전기 신호이다.

### 제어장치가 받아들이는 정보
1. 제어장치는 `클럭 신호`를 받아들인다.
2. 제어장치는 `'해석해야 할 명령어'`를 받아들인다.
3. 제어장치는 플래그 레지스터 속 `플래그 값`을 받아들인다.
4. 제어장치는 시스템 버스, 그중에서 `제어 버스로 전달된 제어 신호`를 받아들인다.

- 즉, 제어장치는 클럭, 현재 수행할 명령어, 플래그, 제어 신호를 받아들인다.

### 제어장치가 내보내는 정보
1. CPU **외부**에 전달하는 제어 신호
- CPU 외부에 제어 신호를 전달하는 말은 제어 버스로 제어 신호를 보낸다는 뜻이다.
- 이러한 제어 신호에는 크게 `메모리`에 전달하는 제어 신호와 `입출력장치(보조기억장치 포함)`에 전달하는 제어 신호가 있다.
- 메모리 : 메모리에 저장된 값을 읽거나 메모리에 새로운 값을 쓰고 싶을 때
- 입출력장치 : 입출력장치의 값을 읽거나 새로운 값을 쓰고 싶을 때

1. CPU **내부**에 전달하는 제어 신호
- `ALU`에 전달하는 제어 신호와 `레지스터`에 전달하는 제어 신호가 있다.
- ALU : 수행할 연산을 지시하기 위해
- 레지스터 : 레지스터 간에 데이터를 이동시키거나 레지스터에 저장된 명령어를 해석하기 위해 제어 신호를 내보낸다.


---

<br>

## 04-2 레지스터
프로그램 속 명령어와 데이터는 실행 전후로 반드시 레지스터에 저장된다. 따라서 레지스터에 저장된 값만 잘 관찰해도 프로그램의 실행 흐름을 파악할 수 있다.  

## 반드시 알아야 할 레지스터 8가지

1. `프로그램 카운터` (PC; Program Counter)
- 메모리에서 읽어 들일 **명령어의 주소를 저장**한다.
- 명령어 포인터(IP; Instruction Pointer)라고도 부른다.

2. `명령어 레지스터`
- 방금 메모리에서 읽어 들인 **명령어를 저장**하는 레지스터
- 제어 장치는 명령어 레지스터 속 명령어를 받아들이고 해석한 뒤 제어 신호를 내보낸다.

3. `메모리 주소 레지스터`
- **메모리의 주소를 저장**하는 레지스터
- 메모리 데이터 레지스터(MDR; Memotry Data Register)라고도 부른다.
- CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거치게 된다.

4. `메모리 버퍼 레지스터`
- **메모리와 주고받을 값(데이터와 명령어)을 저장**하는 레지스터
- 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거친다.

*즉, CPU가 주소 버스로 내보낼 값은 메모리 주소 레지스터를 거치며, 데이터 버스로 주고받을 값은 메모리 버퍼 레지스터를 거친다.

5. `플래그 레지스터`
- **연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장**하는 레지스터

6. `범용 레지스터`
- **데이터와 주소를 모두 저장**할 수 있는 레지스터
- 일반적으로 CPU 안에 여러 개의 범용 레지스터가 있으며, 다양하고 일반적인 상황에서 자유롭게 사용할 수 있다.

7. `스택 포인터`
- `스택의 꼭대기`를 가리키는 레지스터. (= 스택에 마지막으로 저장한 값의 위치를 저장하는 레지스터)
- `스택 주소 지정 방식`이라는 주소 지정 방식에 사용된다.
- 참고로, 스택은 `메모리 안`에 스택처럼 사용할 영역으로 정해져 있다. `스택 영역`이라고 부르며 다른 주소 공간과는 다르게 스택처럼 사용하기로 암묵적으로 약속된 영역이다.

8. `베이스 레지스터`
- 프로그램 카운터와 베이스 레지스터는 `변위 주소 지정 방식`이라는 주소 지정 방식에 사용된다.


## 변위 주소 지정 방식
- 오퍼랜드 필드의 값과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식
- 변위 주소 지정 방식은 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 `상대 주소 지정 방식`, `베이스 레지스터 지정 방식`등으로 나뉜다.

1. 상대 주소 지정 방식
- 오퍼랜드와 `프로그램 카운터`의 값을 더하여 유효 주소를 얻는 방식

2. 베이스 레지스터 지정 방식
- 오퍼랜드와 `베이스 레지스터`의 값을 더하여 유효 주소를 얻는 방식
- 베이스 레지스터는 '기준 주소', 오퍼랜드는 '기준 주소로부터 떨어진 거리'로서의 역할을 한다.

---

<br>

## 04-3 명령어 사이클과 인터럽트

## 명령어 사이클
- 프로그램 속 각각의 명령어들은 일정한 주기가 반복되며 실행되는데, 이 주기를 명령어 사이클이라고 한다.
- 하나의 명령어가 처리되는 주기
- 인출, 실행, 간접, 인터럽트 사이클로 이루어져있다.

1. `인출 사이클` (fetch cycle)
- 메모리에 있는 명령어를 CPU로 가져오는 단계

2. `실행 사이클`
- CPU로 가져온 명령어를 실행하는 단계
- 제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시키는 단계

3. `간접 사이클`
- 간접 주소 지정 방식처럼 메모리 접근이 더 필요한 경우 실행하는 단계

4. `인터럽트 사이클`
- 인터럽트가 발생한 경우 실행하는 단계

  
## 인터럽트
- CPU의 정상적인 작업을 방해하는 신호
- 동기 인터럽트와 비동기 인터럽트로 나뉜다.

### 1. 동기 인터럽트 (synchronous interrupts)
- `CPU`에 의해 발생하는 인터럽트
- CPU가 실행하는 프로그래밍상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생
- `예외(exception)`이라고 부른다.

### 2. 비동기 인터럽트
- 주로 `입출력장치`에 의해 발생하는 인터럽트
- 알림 역할을 한다.
- 일반적으로 비동기 인터럽트를 인터럽트라 칭하기도 하며, `하드웨어 인터럽트`라고도 한다.

## 하드웨어 인터럽트
- 하드웨어 인터럽트를 사용하면 CPU는 주기적으로 입출력 장치의 완료 여부를 확인할 필요가 없이, 인터럽트를 받을 때까지 다른 작업을 처리할 수 있다.

### 하드웨어 인터럽트 처리 순서
1. 입출력장치는 CPU에 `인터럽트 요청 신호`를 보낸다.
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.
3. CPU는 인터럽트 요청을 확인하고 `인터럽트 플래그`를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다.
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다.
5. CPU는 `인터럽트 벡터`를 참조하여 `인터럽트 서비스 루틴`을 실행한다.
6. 인터럽트 서비스 루틴 실행이 끝나면 4.에서 백업해 둔 작업을 복구하여 실행을 재개한다.

*이때, 4번에서 기존에 작업하던 내역들은 인터럽트 서비스 루틴을 실행하기 전에 프로그램 카운터 값 등 현재 프로그램을 재개하기 위해 필요한 모든 내용을 **스택에 백업**한다.

### 인터럽트 요청 신호
- CPU에게 끼어들어도 되는지 묻는 신호

### 인터럽트 플래그
- 하드웨어 인터럽트를 받아들일지, 무시할지 결정하는 비트. 플래그 레지스터 안에 있다.
- 인터럽트 플래그가 불가능으로 설정되어 있어도 무시할 수 없는 인터럽트 요청도 있다.
- 인터럽트 플래그로 막을 수 있는 인터럽트(maskable interrupt)와 막을 수 없는 인터럽트(non maskable interrupt)로 나누기도 한다.

### 인터럽트 서비스 루틴
- 인터럽트를 처리하기 위한 프로그램.
- `인터럽트 핸들러`라고도 부른다.
- 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램

### 인터럽트 벡터
- CPU마다 다른 인터럽트 서비스 루틴을 식별하기 위한 정보
- 인터럽트 서비스 루틴의 시작 주소를 포함하는 인터럽트 서비스 루틴의 식별 정보
- 인터럽트 벡터를 알면 인터럽트 서비스 루틴의 **시작 주소**를 알 수 있기 때문에 CPU는 인터럽트 벡터를 통해 특정 인터럽트 서비스 루틴을 처음부터 실행할 수 있다.


---

### 예외의 종류
- 동기 인터럽트(예외)에는 폴트, 트랩, 중단, 소프트웨어 인터럽트가 있다.

1. `폴트` : 예외 처리 직후 **예외가 발생한 명령어**부터 실행을 재개하는 예외
2. `트랩` : 예외 처리 직후 예외가 발생한 명령어의 **다음 명령어**부터 실행을 재개하는 예외. 주로 `디버깅`할 때 사용한다.
3. `중단(abort)` : CPU가 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류를 발견했을 때 발생하는 예외
4. `소프트웨어 인터럽트` : 시스템 호출이 발생했을 때 나타난다.

*디버깅 : 프로그램 개발 중에 발생한 문제를 진단하고 해결하기 

<br>

#### 출처  
[1] 혼자 공부하는 컴퓨터구조 + 운영체제 - 강민철 지음
