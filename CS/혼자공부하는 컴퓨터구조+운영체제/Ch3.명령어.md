# CH03 명령어

## 03-1 소스코드와 명령어

## 고급 언어와 저급 언어
- 사람을 위한 언어를 `고급 언어`(high-level programming language), 컴퓨터가 직접 이해하고 실행할 수 있는 언어를 `저급 언어`(low-level programming language)라고 한다.
- 컴퓨터가 이해하고 실행할 수 있는 언어는 오직 저급 언어뿐이다.
- 그래서 고급 언어로 작성된 소스 코드가 실행되려면 반드시 저급 언어, 즉 명령어로 변환되어야 한다.
- 저급 언어에는 `기계어`와 `어셈블리어` 두 가지가 있다.
- `기계어`란, 0과 1의 명령어 비트로 이루어진 언어이다.
- 0과 1로 표현된 명령어(기계어)를 읽기 편한 형태로 번역한 언어가 `어셈블리어`다.

## 컴파일 언어와 인터프리터 언어
- 고급 언어로 작성한 소스 코드는 저급 언어로 변환되어 실행된다. 이때, 컴파일 방식으로 작동하는 프로그래밍 언어를 `컴파일 언어`, 인터프리터 방식으로 작동하는 프로그래밍 언어를 `인터프리터 언어`라고 한다.

1. 컴파일 언어
- 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어. 대표적인 컴파일 언어로는 C가 있다.
- 이때, 컴파일 언어로 작성된 소스 코드가 전체가 저급 언어로 변환되는 과정을 컴파일이라고 하며, 컴파일을 수행해주는 도구를 컴파일러라고 한다.
- 컴파일러를 통해 저급 언어로 변환된 코드를 `목적 코드(object code)`라고 한다.

2. 인터프리터 언어
- 인터프리터 언어는 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어다. 대표적으로 Python이 있다.
- 소스 코드 전체가 저급 언어로 변환되는 컴파일 언어와 달리, 인터프리터 언어는 소스 코드를 `한 줄씩 차례로 실행`한다.
- 소스코드를 한 줄씩 저급 언어로 변환하여 실행해주는 도구를 `인터프리터`라고 한다.
- 컴파일 언어와 달리, n번째 줄에 문법 오류가 있더라도 n-1번째 줄까지는 올바르게 수행된다.

#### 컴파일 언어 vs 인터프리터 언어 속도 비교
- 일반적으로 인터프리터 언어는 컴파일 언어보다 느리다. 
- 목적 코드는 컴퓨터가 이해하고 실행할 수 있는 저급 언어인 반면, 인터프리터 언어는 소스 코드 마지막에 이를 때까지 한 줄 한 줄씩 저급 언어로 해석하며 실행해야 하기 때문이다.

### 목적 파일 VS 실행 파일
- 목적 코드로 이루어진 파일을 `목적 파일`, 실행 코드로 이루어진 파일을 `실행 파일`이라고 부른다.
- 목적 코드가 실행 파일이 되기 위해서는 `링킹`이라는 작업을 거쳐야 한다.
- 실행 파일이 실행되면 실행 파일에 없고 목적 코드에 있는 외부 기능들을 실행 파일과 연결지어야만 실행할 수 있다. 이렇게 연결 짓는 작업을 `링킹(linking)`이라고 한다.
- 링킹 작업까지 거쳐야 비로소 하나의 실행 파일이 만들어진다.

---

## 03-2 명령어의 구조

## 연산 코드와 오퍼랜드
- 기계어와 어셈블리어를 이루는 하나하나는 `명령어`이며, 명령어는 `연산 코드`와 `오퍼랜드`로 구성되어 있다.
- **명령어가 수행할 연산**을 연산 코드라고 하며, **연산에 사용할 데이터** 또는 **연산에 사용할 데이터가 저장된 위치**를 오퍼랜드라고 한다.

1. 오퍼랜드
- 오퍼랜드가 담기는 영역인 오퍼랜드 필드에는 숫자와 문자 등을 나타내는 `데이터` 또는 `메모리나 레지스터 주소`가 올 수 있다.
- 오퍼랜드 필드에는 사용할 데이터를 직접 명시하기 보다는 많은 경우에 연산에 사용될 데이터가 저장된 위치를 담는다. 그래서 오퍼랜드 필드를 `주소 필드`라고 부르기도 한다.
- 오퍼랜드는 명령어 안에 0개 일수도 있고, 1개, 2개 이상일 수도 있다.
- 오퍼랜드가 하나도 없는 명령어를 0-주소 명령어, 하나인 명령어를 1-주소 명령어라고 부른다.

2. 연산 코드
- 연산 코드는 명령어가 수행할 연산을 의미하며, 크게 4가지로 나눌 수 있다.

> 1) 데이터 전송 : MOVE, STORE, LOAD(FETCH), PUSH, POP
> 2) 산술/논리 연산 : ADD/SUBSTRACT/MULTIPLY/DIVIDE, INCREMENT/DECREMENT, AND/OR/NOT, COMPARE
> 3) 제어 흐름 변경 : JUMP, CONDITIONAL JUMP, HALT, CALL, RETURN
> 4) 입출력 제어 : READ, WRITE, START IO, TEST IO

## 주소 지정 방식
- 오퍼랜드 필드에 메모리나 레지스터의 주소를 담는 이유는 `명령어 길이` 때문이다.
- 오퍼랜드 필드 안에 데이터 대신 메모리 주소가 담긴다면 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커지게 된다.
- 연산 코드에 사용할 데이터가 저장된 위치, 즉 **연산의 대상이 되는 데이터가 저장된 위치**를 `유효 주소`라고 한다.
- 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법을 주소 지정 방식(addressing mode)이라고 한다.  
- **즉, 주소 지정 방식은 연산에 사용할 데이터 위치를 찾는 방법이다.**

<br>

1. 즉시 주소 지정 방식 (immediated addressing mode)
- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식.
- 단점 : 표현할 수 있는 데이터의 크기가 작아진다.
- 장점 : 데이터를 메모리나 레지스터로부터 찾는 과정이 없기 때문에 빠르다.
<center>
  <img
    src="https://i.imgur.com/2mC8wvI.png"
    width="500"
    height="80"
  />
</center>
<br>

2. 직접 주소 지정 방식 (direct addressing mode)
- 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식
- 오퍼랜드 필드에서 표현할 수 있는 데이터의 크기는 즉시 주소 지정 방식보다 더 커졌지만, 여전히 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 줄어든다.
- 따라서 표현할 수 있는 유효 주소에 제한이 생길 수 있다.

<center>
  <img
    src="https://i.imgur.com/Xwm6uZQ.png"
    width="500"
    height="200"
  />
</center>
<br>

3. 간접 주소 지정 방식 (indirect addressing mode)
- 유효 주소의 주소를 오퍼랜드 필드에 명시하는 방식
- 단점 : 두 번의 메모리 접근이 필요하기 때문에 일반적으로 느리다.

<center>
  <img
    src="https://i.imgur.com/rJLsblW.png"
    width="500"
    height="200"
  />
</center>
<br>

4. 레지스터 주소 지정 방식
- 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법
- 일반적으로 CPU 외부에 있는 메모리에 접근하는 것보다 레지스터에 접근하는 것이 더 빠르므로 직접 주소 지정 방식보다 빠르게 접근할 수 있다.
- 단점 : 표현할 수 있는 레지스터 크기에 제한이 생길 수 있다.

<center>
  <img
    src="https://i.imgur.com/rwEtpVV.png"
    width="500"
    height="200"
  />
</center>
<br>

5. 레지스터 간접 주소 지정 방식
- 연산에 사용할 데이터를 메모리에 저장하고, 그 유효 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법
- 간접 주소 지정 방식과 비슷하지만, 메모리에 접근하는 횟수가 한 번으로 줄어든다는 장점이 있다.

<center>
  <img
    src="https://i.imgur.com/G3tcFSd.png"
    width="500"
    height="200"
  />
</center>
<br>


<br>

#### 출처  
[1] 혼자 공부하는 컴퓨터구조 + 운영체제 - 강민철 지음
