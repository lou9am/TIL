# CH05 CPU 성능 향상 기법

## 05-1 빠른 CPU를 위한 설계 기법

## 클럭
- 클럭 속도는 Hz 단위로 측정한다. 클럭이 1초에 100번 반복되면 CPU 클럭 속도는 100Hz이다.
- 일반적으로 클럭 속도가 높은 CPU가 성능이 좋다.
- 그래서 클럭 속도는 CPU 속도 단위로 간주되기도 한다.
- 클럭 속도를 높이면 CPU를 빠르게 만들지만, 발열 문제가 생기고 성능 향상에 한계가 있다.

### 오버클럭킹
- 클럭 속도는 일정하지 않다. 고성능을 요구하는 순간에 순간적으로 클럭 속도를 높이고, 그렇지 않을 때는 유연하게 클럭 속도를 낮추기도 한다.
- 최대 클럭 속도를 강제로 더 끌어올리는 기법을 `오버클럭킹(overclocking)`이라고 한다.

## 코어와 멀티코어

### `코어`
- 코어는 **명령어를 실행하는 부품**으로 여러 개 있을 수 있다.
- 오늘날 CPU는 단순히 '명령어를 실행하는 부품'에서 '명령어를 실행하는 부품을 여러 개 포함하는 부품'으로 명칭의 범위가 확장되었다.

### `멀티코어`
- 코어를 여러개 포함하고 있는 CPU를 `멀티코어 CPU` 또는 `멀티코어 프로세서`라고 부른다.
- CPU의 연산 속도가 꼭 코어 수에 비례하여 증가하지는 않는다.

## 스레드와 멀티스레드

### `스레드`
- 실행 흐름의 단위
- CPU에서 사용되는 정의와 프로그래밍에서 사용되는 정의가 다르다.

1. `하드웨어적 스레드`
- CPU에서 사용되는 스레드
- 논리 프로세서라고도 한다.
- 하나의 코어가 동시에 처리하는 명령어 단위
- **하나의 코어로 여러 명령어를 동시에 처리**하는 CPU를 `멀티스레드 프로세서` 또는 `멀티스레드 CPU`라고 한다.

*하이퍼스레딩 : 인텔의 멀티스레드 기술

2. `소프트웨어적 스레드`
- 하나의 프로그래밍에서 독립적으로 실행되는 단위

### 멀티스레드 프로세서
- 여러 개의 하드웨어적 스레드를 지원하는 CPU
- 하나의 명령어를 처리하기 위해 꼭 필요한 레지스터를 여러 개 가지고 있으면 된다.


---

<br>

## 05-2 명령어 병렬 처리 기법
- 빠른 CPU를 만들려면 명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시켜야 한다. 이러한 기법을 `명령어 병렬 처리 기법`(ILP; Instruction-Level Parallelism)이라고 한다.
- ILP에는 명령어 파이프라이닝, 슈퍼스칼라, 비순차적 명령어 처리가 있다.

## 명령어 파이프라이닝
- 동시에 여러 개의 명령어를 겹쳐 실행하는 기법
- 높은 성능을 가져오긴 하지만, 특정 상황에서는 성능 향상에 실패하는 경우가 있다. 이러한 상황을 `파이프라인 위험`(pipeline hazard)이라고 한다.
- 파이프라인 위험에는 크게 데이터 위험, 제어 위험, 구조적 위험이 있다.

1. `데이터 위험`
- 명령어 간 데이터 의존성에 의해 발생
- 데이터 의존적인 두 명령어를 무작정 동시에 실행하려고 하는 경우 파이프라인이 제대로 작동하지 않는다.

2. `제어 위험`
- 분기 등으로 인한 '프로그램 카운터의 갑작스러운 변화'에 의해 발생
- 이를 위해 `분기 예측`(branch prediction)이라는 기술을 사용해 프로그램이 어디로 분기할지 미리 예측, 그 주소를 인출하기도 한다.

3. `구조적 위험`
- 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생한다.
- 구조적 위험은 자원 위험(resource hazard)이라고도 부른다.


## 슈퍼스칼라
- 여러 개의 명령어 파이프라인을 두는 기법
- 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU를 `슈퍼스칼라 프로세서` 또는 `슈퍼스칼라 CPU`라고 부른다.


## 비순차적 명령어 처리 (OoOE;Out-of-order execution)
- 데이터 의존성이 전혀 없는, 순서를 바꿔 처리해도 수행 결과에 영향을 미치지 않는 명령어들이 있다.
- 이렇게 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법
- 파이프라인의 중단을 방지하기 위해 명령어를 순차적으로 처리하지 않는 명령어 병렬 처리 기법

---

<br>

## 05-3 CISC와 RISC

## 명령어 집합
- CPU가 이해할 수 있는 명령어들의 모음
- 명령어 집합 또는 명령어 집합 구조(ISA;Instruction Set Architecture)라고 한다.
- CPU마다 ISA가 다를 수 있다.
- ISA는 CPU의 언어이자 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속이다.

## CISC
- Complex Instruction Set Computer
- 복잡하고 다양한 수의 가변 길이 명령어를 활용한다.
- 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있다.
- 메모리 공간을 절약할 수 있으나, 명령어의 크기와 실행되기까지의 시간이 일정하지 않다.
- 명령어의 규격화가 어려워 파이프라이닝이 어렵다.

## RISC
- Reduced Instruction Set Computer
- CISC에 비해 명령어의 종류가 적다.
- CISC와 달리 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어를 지향한다.
- 단순하고 적은 수의 고정 길이 명령어를 활용한다.
- 명령어 파이프라이닝에 최적화되어 있다.
- 메모리 접근을 단순화하고 최소화를 추구해서 load-store 구조라고도 부른다.
- 대신 레지스터를 적극적으로 활용하기 때문에 CISC보다 레지스터를 이용하는 연산이 많고, 범용 레지스터 개수도 일반적으로 더 많다.

## CISC vs RISC
|CISC|RISC|
|--|--|
|복잡하고 다양한 명령어|단순하고 적은 명령어|
|가변 길이 명령어|고정 길이 명령어|
|다양한 주소 지정 방식|적은 주소 지정 방식|
|프로그램을 이루는 명령어의 수가 적음|프로그램을 이루는 명령어의 수가 많음|
|여러 클럭에 걸쳐 명령어 수행|1클럭 내외로 명령어를 수행|
|파이프라이닝하기 어려움|파이프라이닝하기 쉬움|

 
<br>

#### 출처  
[1] 혼자 공부하는 컴퓨터구조 + 운영체제 - 강민철 지음
