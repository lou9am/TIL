- C++에서는 사용자 정의 헤더가 아닌 표준 헤더 파일들은 모두 .h 확장명을 생략한다.
- `int a`에서 a는 int 자료형에 대한 인스턴스다.
- C++에서는 '변수' 라는 표현보다는 '인스턴스'라는 표현에 익숙해져야 한다.
- 객체지향 프로그래밍에서는 모든 것을 다 객체로 표현하고 객체의 형식을 갖는 변수를 인스턴스라고 한다.
- std 네임스페이스에 속한 cout 객체는 iostream 클래스의 인스턴스(혹은 객체)이다.

### 자료형
`int a = 10;`
`int a(10);`
`int b(a);`
##### auto
- 초기값의 형식에 맞춰 선언하는 인스턴스의 형식이 '자동'으로 결정된다.
- 
##### decltype (expr)



##### new와  delete 연산자
- C++에서 객체를 동적 할당하고 해제하는 연산자
```
// 단일 인스턴스의 경우
형식 *변수이름 = new 형식;
delete 변수이름;

// 배열의 경우
형식 *변수이름 = new 형식[요소개수];
delete[] 변수이름;
```
- new는 malloc과 달리 메모리 크기를 정하지 않는다.
- (주의!) 배열 형태로 동적 생성한 것은 반드시 배열 형태를 통해 삭제해야 한다.
- new 연산자는 객체의 생성자를 호출하고, delete 연산자는 객체의 소멸자를 호출한다.

##### 참조자 형식
- 반드시 선언과 동시에 초기화해야 한다.
- 따라서, 원래 변수가 없는 참조자란 애초부터 없다.
- 상수에는 포인터를 선언할 수 없는 것처럼 상수에는 참조자를 선언할 수 없다.
`형식 &이름 = 원본;`
예시 : `int &rData = a;`

```
int *pData = &3; // 포인터는 상수에 불가능
int &rData = 3;  // 상수에 대한 참조는 불가능
int &rData; // 참조 원본이 없으므로 불가능
```

##### 참조형 변수 선언과 정의
- 참조형 변수(또는 참조자)는 처음 어떤 변수와 짝을 이루게 되면 그 짝이 달리지지 않는다.
- 짝을 이룬 원래 변수가 달라진 것을 감지해주는 것도 아니다.
- 포인터의 일반적인 사용문제 몇 가지를 문법적으로 차단했다.
- 겉으로 보기에는 전혀 포인터로 보이지 않는다!
- 참조자의 값을 변경하면 원본도 변경된다.
- 참조 == 주소
- 함수의 매개변수가 참조자인 경우 가장 큰 문제점은 호출자 코드만 봐서는 매개변수가 참조 형식이라는 사실을 전혀 알 수 없다는 것이다. 따라서, C++에서는 절대로 호출자 코드만 보고 함수의 원형을 확신해서는 안 된다.
- C++에서는 의도적으로 포인터를 사용하지 말고 참조 형식을 사용하자!!

##### r-value 참조 (C++ 11부터 사용 가능)
- r-value란, 대입 연산자의 두 피연산자 중 오른쪽에 위치한 연산자
- 일반적인 변수와 상수 모두 해당될 수 있다.
`int &&rdata = 3;`

- 임시 결과는 이어지는 연산에 활용된 직후 소멸되는 r-value이다.
- r-value 참조자는 이제 곧 사라질 대상에 대해 참조자를 부여할 수 있다.


##### 범위 기반 for문
```
for(auto 요소변수 : 배열이름)
	반복 구문;
```
- 반복 횟수는 배열 요소 개수에 맞춰 자동으로 결정된다.
```
for(auto &n : aList)
// 이렇게 참조자를 요소 형식으로 선언하면 중간에 중간에 배열에 값이 바뀌어도 각 배열의 모든 요소가 바뀜
```
- 전체 배열 요소에 접근할 때 범위 기반 for문을 사용할 것!

